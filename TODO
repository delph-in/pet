- finish lexdb
- Memory leak seems to be not ignoreable
- finish modlist class or make it obsolete

- mmap problems seem to come up again and again!
  Idea: Make sure that permanent dags avoid using one of the slots that are 
        used for unification and mark it with a special value. May not be 
        feasible 

- remove all uses of negative values as `marker'-values, especially where casts
  from integers to pointers and back are involved. 

- multiple irregs files as in LKB (gimmick)

- divergence in the case of chart dependencies:
  this problem stems from the fact that in PET chart dependencies are applied
  either after or before lexical AND inflectional rules have been tried on
  the input items. It is wrong to do only inflectional rules and then lexical
  rules because lexical rules could be interleaved with inflectional rules.
  The only other meaningful solution to that would be to postpone applying
  lexical rules to items with zero length infl rules as long as possible.
  The first applicance of the filter would then be after all items with
  non-empty infl rules list had been expanded to the point where all possible 
  infl rules had been applied, but not the remaining lexical rules.

- flop returns zero even in the presence of errors like non-unique feature
  introduction

- API!!! and maybe cheap dynamic library
  - restarting a parse stopped because the first result arrived
  - determining the subset of results to retrieve
  - determine the desired output format(s) (multiple formats may be desired, 
    without reparse!)
  - set/change options/settings through API (a part of "clean up:options")

- scoring:
  - offline scoring
  - simplified model for compatibility ??  What does that mean ?

- What does "duplicate failure path" mean? How is it that it occurs with the 
  new restrictors under unification

- Better error handling in flop for use with external applications
- emacs compatible error messages for flop ?
- flop does not dump (multiply) cyclic structures
  - test dag restrictor once this is fixed

- Documentation
  - flop & cheap user doc
  - missing header file documentation (oe, please help here, if possible)
    itsdb.h, extdict.h, psqllex.h, tsdb++.h

- unreleased memory? (see valgrind-errors-15-apr-04)

- more flexible way to do selection of generic entries, e.g., based only on a 
  (highly scored) subset of POS, or combined clues from morphology

- more flexible heuristics / better selection of partial results

- cleaning up:
  - option handling
  - logging / debugging info: get rid of global verbosity,
    implement some central logging facility (take Apache log4cxx)
  - YY references; split yy.cpp module into separate modules
    - server mode still unused, yy.cpp/h should become socket.cpp/h

- complete lexical database (postgres) integration

- integrate silo

- lsl completion - minimal ?? What does that mean ?

- packing:
  - fix & integrate subsumption quickcheck
    currently, it gives incorrect results for non-existing paths
  - simplify/optimise subsume
  - subtype caching
  - re-enable unfilling as far as possible 

- defaults

- generator

- whenever dag_get_path_value is called, structure should be filled, at least
  under that path.

- extend chart dependencies to allow a dependency to be conditioned on
  a specified path-value pair. chart dependencies could take a variety of
  forms: (OP could be unifies, subsumes, is_subsumed_by, equals)
  - val(path1) OP val(path2)
  - val(path1) OP const1 && val(path2) OP const2
  - val(path1) OP const1 && val(path1) OP val(path2)
  - val(path1) OP val(path2) && val(path2) OP const2  (??)

refactoring:
- make tAgenda a template
- make the unification engine(s) more modular
- better decoupling of the dag allocation mechanism
- replace item print routines by item printers where possible

- diagnostic messages for errors in the MRS construction
- performance loss compared zu ~kiefer/duo/public/pet-730.tgz is 30% --
  because of the data structures in the chart that are necessary for packing,
  like _Cp_span? this has to be checked.


+ apply chart dependencies after lexical processing
  + chart dependencies after lex lookup (1) AND lex processing (2)
  + still to be tested, Berthold will try it: Seems to work
+ flop performance improvement
  performance loss flop Leda vs. flop boost: stems from a huge amount 
  of minor page faults and cache faults. The huge edge list produced lots of
  non-local accesses, which was fixed by looping over the vertices in the right
  order and thereby localizing the access to the out-edges of each vertex
+ irregs as last rule in the affixation analysis: solved in the last oe patches
+ bei characterization immer reinknallen, egal ob das Feature da ist oder 
  nicht: d.h. man geht den Pfad runter bis auf das letzte Element und
  unifiziert so lange first.lastfeat|type, rest.first.lastfeat|type,
  bis das klappt
